#!/bin/sh
set -e
(set -o pipefail) 2>/dev/null || true

# --- 1. Locate Laravel Project ---
ARTISAN_FILE="$(find / -type f -name artisan 2>/dev/null | head -n1)"
if [ -z "$ARTISAN_FILE" ]; then
  echo "ERROR: Could not find Laravel 'artisan' file. Exiting."
  exit 1
fi
APP_DIR="$(dirname "$ARTISAN_FILE")"
cd "$APP_DIR"
echo "âœ… Laravel project found at $APP_DIR"

# --- 2. Configure Environment (.env) ---
if [ -f /etc/secrets/.env ]; then
  echo "Found secret file, copying to .env"
  cp /etc/secrets/.env "$APP_DIR/.env"
else
  echo "No secret file found. Building .env from environment variables."
  : "${APP_URL:=${RENDER_EXTERNAL_URL:-https://cattr-app.onrender.com}}"

  if [ -z "$DATABASE_URL" ]; then
    DATABASE_URL="mysql://${DB_USERNAME}:${DB_PASSWORD}@${DB_HOST}:${DB_PORT}/${DB_DATABASE}?ssl-mode=VERIFY_IDENTITY"
  fi

  cat > "$APP_DIR/.env" <<EOF
# --- Generated by start.sh ---
APP_NAME=Cattr
APP_ENV=production
APP_DEBUG=false
APP_KEY=${APP_KEY}
APP_URL=${APP_URL}
DATABASE_URL=${DATABASE_URL}
DB_CONNECTION=mysql
DB_HOST=${DB_HOST}
DB_PORT=${DB_PORT}
DB_DATABASE=${DB_DATABASE}
DB_USERNAME=${DB_USERNAME}
DB_PASSWORD=${DB_PASSWORD}
MYSQL_ATTR_SSL_CA=${MYSQL_ATTR_SSL_CA:-/etc/ssl/certs/ca-certificates.crt}
EOF
fi
sed -i 's/\r$//' "$APP_DIR/.env" || true

append_if_missing () {
  KEY="$1"; VALUE="$2"
  grep -q "^${KEY}=" "$APP_DIR/.env" || echo "${KEY}=${VALUE}" >> "$APP_DIR/.env"
}
echo "Appending safe defaults for cache, session, and queue drivers..."
append_if_missing LOG_CHANNEL stderr
append_if_missing CACHE_DRIVER file
append_if_missing SESSION_DRIVER file
append_if_missing QUEUE_CONNECTION sync

# --- 2b. Generate App Key If Missing ---
if [ -z "${APP_KEY:-}" ] || ! grep -q '^APP_KEY=' "$APP_DIR/.env"; then
  echo "Generating APP_KEY..."
  php artisan key:generate --force
fi

# --- 3. Enforce TLS for Database Connection ---
DBCFG="$APP_DIR/config/database.php"
if [ -f "$DBCFG" ] && ! grep -q "PDO::MYSQL_ATTR_SSL_CA" "$DBCFG"; then
  echo "Patching config/database.php to enforce TLS..."
  cp "$DBCFG" "$DBCFG.bak"
  awk '
    BEGIN{inmysql=0; hasopt=0}
    { print }
    $0 ~ /'\''mysql'\''[[:space:]]*=>[[:space:]]*\[/ { inmysql=1; next }
    inmysql==1 && $0 ~ /options[[:space:]]*=>/ { hasopt=1 }
    inmysql==1 && $0 ~ /\],[[:space:]]*$/ {
      if (hasopt==0) {
        print "            '\''options'\'' => extension_loaded('\''pdo_mysql'\'') ? array_filter([\n                PDO::MYSQL_ATTR_SSL_CA => env('\''MYSQL_ATTR_SSL_CA'\''),\n            ]) : [],"
      }
      inmysql=0
    }
  ' "$DBCFG" > "$DBCFG.tmp" && mv "$DBCFG.tmp" "$DBCFG"
  echo "âœ… TLS configured."
fi

# --- 4. Dynamically Patch & Skip Migrations ---
MIGRATIONS_DIR="$APP_DIR/database/migrations"
if [ -d "$MIGRATIONS_DIR" ]; then
  echo "Scanning for incompatible and obsolete migrations..."

  # Rule 1: Skip migrations that use database triggers/procedures/functions
  { grep -rilE 'CREATE[[:space:]]+(TRIGGER|PROCEDURE|FUNCTION)|DROP[[:space:]]+(TRIGGER|PROCEDURE|FUNCTION)' "$MIGRATIONS_DIR" 2>/dev/null || true; } \
  | grep -v '\.skipped$' \
  | while read -r f; do
      [ -f "$f" ] || continue
      echo "  -> Disabling unsupported migration (trigger/procedure): $f"
      mv "$f" "$f.skipped"
    done

  # Rule 2: Skip migrations with known duplicate indexes
  find "$MIGRATIONS_DIR" -type f -name '*add_index*.php' ! -name '*.skipped' \
  | while read -r f; do
      echo "  -> Disabling duplicate-index migration: $f"
      mv "$f" "$f.skipped"
    done
  
  # Rule 3: Skip a list of specific obsolete migrations
  OBSOLETE_MIGRATIONS="
  2018_09_27_100017_update_rules.php
  2018_11_02_121027_create_registrations_table.php
  2020_01_14_061358_fixes_for_roles.php
  2020_02_04_080909_fix_user_roles.php
  "
  echo "Disabling obsolete migrations:"
  echo "$OBSOLETE_MIGRATIONS" | while read -r migration_file; do
    [ -z "$migration_file" ] && continue
    TARGET_FILE="$MIGRATIONS_DIR/$migration_file"
    if [ -f "$TARGET_FILE" ]; then
      echo "  -> Skipping $TARGET_FILE"
      mv "$TARGET_FILE" "$TARGET_FILE.skipped"
    fi
  done
fi

# Rule 4: Find & replace the TiDB-incompatible view migration ANYWHERE in the app
echo "Scanning project for user_time_activity view migrations (any path)..."
ALL_VIEW_MIGS="$(
  {
    find "$APP_DIR" -path "$APP_DIR/vendor" -prune -o -path "$APP_DIR/storage" -prune -o -type f -name '*.php' \( \
      -iname '*user_time_activity*.php' -o \
      -iname '*user*last*time*usage*view*.php' -o \
      -iname '2019_03_26_113406_add_user_last_time_usage_view.php' \
    \) -print 2>/dev/null;
    { grep -rilE 'CREATE([[:space:]]+OR[[:space:]]+REPLACE)?[[:space:]]+VIEW[[:space:]]+`?user_time_activity`?|user_time_activity' "$APP_DIR" 2>/dev/null || true; } | grep -v '/vendor/' | grep -v '/storage/';
    { grep -rilE 'AddUserLastTimeUsageView' "$APP_DIR" 2>/dev/null || true; } | grep -v '/vendor/' | grep -v '/storage/';
  } | sort -u
)"
ALL_VIEW_MIGS="$(printf "%s\n" "$ALL_VIEW_MIGS" | grep -vE '\.skipped$|_tidb\.php$' || true)"

if [ -n "$ALL_VIEW_MIGS" ]; then
  echo "Found and disabling incompatible view migration(s):"
  printf '%s\n' "$ALL_VIEW_MIGS" | while read -r f; do
    [ -f "$f" ] || continue
    if echo "$f" | grep -q '/database/'; then
      echo "  -> Skipping $f"
      mv "$f" "$f.skipped"
    elif grep -Eq 'CREATE([[:space:]]+OR[[:space:]]+REPLACE)?[[:space:]]+VIEW[[:space:]]+`?user_time_activity`?' "$f"; then
      echo "  -> Skipping $f (contains CREATE VIEW)"
      mv "$f" "$f.skipped"
    fi
  done

  TS="$(date +%Y_%m_%d_%H%M%S)"
  VIEW_MIG_NEW="$MIGRATIONS_DIR/${TS}_add_user_last_time_usage_view_tidb.php"
  cat > "$VIEW_MIG_NEW" <<'PHP'
<?php
use Illuminate\Support\Facades\DB;
use Illuminate\Database\Migrations\Migration;
class AddUserLastTimeUsageViewTidb extends Migration
{
    public function up()
    {
        DB::statement('DROP VIEW IF EXISTS user_time_activity');
        DB::statement(<<<'SQL'
CREATE VIEW user_time_activity AS SELECT ti.id AS time_interval_id, ti.user_id, ti.task_id, ti.end_at AS last_time_activity FROM time_intervals ti JOIN (SELECT user_id, MAX(end_at) AS max_end_at FROM time_intervals GROUP BY user_id) tmax ON ti.user_id = tmax.user_id AND ti.end_at = tmax.max_end_at
SQL
        );
    }
    public function down()
    {
        DB::statement('DROP VIEW IF EXISTS user_time_activity');
    }
}
PHP
  echo "  -> Added compatible replacement: $VIEW_MIG_NEW"
fi

# Rule 5: Create Role model shims to fix legacy code
if [ ! -f "$APP_DIR/app/Models/Role.php" ]; then
  echo "Creating strengthened App\\Models\\Role model (not found)..."
  mkdir -p "$APP_DIR/app/Models"
  cat > "$APP_DIR/app/Models/Role.php" <<'PHP'
<?php
namespace App\Models;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\SoftDeletes;
use Illuminate\Support\Facades\Schema;
class Role extends Model
{
    use SoftDeletes;
    protected $table = 'role';
    public $timestamps = false;
    protected $guarded = [];
    public function getKeyName()
    {
        try {
            if (Schema::hasColumn($this->getTable(), 'role_id')) {
                return 'role_id';
            }
        } catch (\Throwable $e) {}
        return 'id';
    }
}
PHP
fi
if [ ! -f "$APP_DIR/app/Models/Rule.php" ]; then
  echo "Creating compatibility shim App\\Models\\Rule extends Role..."
  cat > "$APP_DIR/app/Models/Rule.php" <<'PHP'
<?php
namespace App\Models;
class Rule extends Role {}
PHP
fi

# Rule 6: Bootstrap role table BEFORE legacy migrations run
TS_BOOT="2020_01_05_000000"
BOOT_MIG="$MIGRATIONS_DIR/${TS_BOOT}_bootstrap_roles_table_compat.php"
if [ ! -f "$BOOT_MIG" ]; then
  cat > "$BOOT_MIG" <<'PHP'
<?php
use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;
class BootstrapRolesTableCompat extends Migration
{
    public function up()
    {
        if (!Schema::hasTable('role')) return;
        Schema::table('role', function (Blueprint $table) {
            if (!Schema::hasColumn('role','role_id')) {
                $table->unsignedInteger('role_id')->nullable()->index('role_role_id_idx');
            }
            if (!Schema::hasColumn('role','deleted_at')) {
                $table->softDeletes();
            }
            if (!Schema::hasColumn('role','object')) {
                $table->string('object')->nullable()->index('role_object_idx');
            }
            if (!Schema::hasColumn('role','action')) {
                $table->string('action')->nullable()->index('role_action_idx');
            }
        });
    }
    public function down() { /* Down migration intentionally left empty */ }
}
PHP
  echo "  -> Added compat migration: $BOOT_MIG"
fi

# FINAL STEP before migrating: Refresh the autoloader to find our new classes
if command -v composer >/dev/null 2>&1; then
  echo "Refreshing Composer autoloader to detect new migration files..."
  composer dump-autoload -o || true
fi

# --- 5. Prepare and Launch Application ---
: "${PORT:=10000}"

echo "Ensuring writable dirs..."
mkdir -p storage bootstrap/cache
chmod -R ug+rwX storage bootstrap/cache || true
chown -R www-data:www-data storage bootstrap/cache 2>/dev/null || true
php artisan storage:link || true

echo "Clearing caches..."
php artisan config:clear
php artisan route:clear
php artisan view:clear
php artisan cache:clear

echo "Optimizing for production..."
php artisan optimize || true

run_migrate () {
  for i in 1 2 3 4 5; do
    php artisan migrate --force --no-interaction && return 0
    echo "Migrate attempt $i failed; retrying in 5s..."
    sleep 5
  done
  echo "Migrations failed after retries"; return 1
}

run_fresh () {
  for i in 1 2 3 4 5; do
    php artisan migrate:fresh --seed --force && return 0
    echo "migrate:fresh attempt $i failed; retrying in 5s..."
    sleep 5
  done
  echo "migrate:fresh failed after retries"; return 1
}

# Gate destructive migration command behind an environment variable
if [ "${RESET_DB:-0}" = "1" ]; then
  echo "RESET_DB=1 found. Wiping database and running all migrations from scratch..."
  run_fresh
else
  echo "RESET_DB is not 1. Running incremental migrations..."
  run_migrate
  # Optionally run seeders on incremental deploys if flag is set
  if [ "${RUN_SEED:-0}" = "1" ]; then
    echo "RUN_SEED=1 found. Running database seeder..."
    php artisan db:seed --force
  fi
fi

echo "ðŸš€ Starting Cattr application server..."
php artisan serve --host 0.0.0.0 --port "$PORT"
