#!/bin/sh
set -e

# --- 1. Locate Laravel Project ---
# Find the 'artisan' file to locate the project root directory.
ARTISAN_FILE="$(find / -type f -name artisan 2>/dev/null | head -n1)"
if [ -z "$ARTISAN_FILE" ]; then
  echo "ERROR: Could not find Laravel 'artisan' file. Exiting."
  exit 1
fi
APP_DIR="$(dirname "$ARTISAN_FILE")"
cd "$APP_DIR"
echo "âœ… Laravel project found at $APP_DIR"

# --- 2. Configure Environment (.env) ---
# Use the .env file from Render's secret files if it exists.
# Otherwise, create a .env file from individual environment variables.
if [ -f /etc/secrets/.env ]; then
  echo "Found secret file, copying to .env"
  cp /etc/secrets/.env "$APP_DIR/.env"
else
  echo "No secret file found. Building .env from environment variables."
  # Set default APP_URL if not provided
  : "${APP_URL:=https://cattr-app.onrender.com}"

  # Construct the DATABASE_URL for TiDB Serverless, which requires TLS.
  if [ -z "$DATABASE_URL" ]; then
    DATABASE_URL="mysql://${DB_USERNAME}:${DB_PASSWORD}@${DB_HOST}:${DB_PORT}/${DB_DATABASE}?ssl-mode=VERIFY_IDENTITY"
  fi

  cat > "$APP_DIR/.env" <<EOF
# --- Generated by start.sh ---
APP_NAME=Cattr
APP_ENV=production
APP_DEBUG=false
APP_KEY=${APP_KEY}
APP_URL=${APP_URL}
DATABASE_URL=${DATABASE_URL}
DB_CONNECTION=mysql
DB_HOST=${DB_HOST}
DB_PORT=${DB_PORT}
DB_DATABASE=${DB_DATABASE}
DB_USERNAME=${DB_USERNAME}
DB_PASSWORD=${DB_PASSWORD}
MYSQL_ATTR_SSL_CA=${MYSQL_ATTR_SSL_CA:-/etc/ssl/certs/ca-certificates.crt}
EOF
fi
# Ensure the file has Unix line endings
sed -i 's/\r$//' "$APP_DIR/.env" || true

# --- 2b. Generate App Key If Missing ---
if [ -z "${APP_KEY:-}" ] || ! grep -q '^APP_KEY=' "$APP_DIR/.env"; then
  echo "Generating APP_KEY..."
  php artisan key:generate --force
fi

# --- 3. Enforce TLS for Database Connection ---
# Modify Laravel's database config to use the SSL CA certificate.
DBCFG="$APP_DIR/config/database.php"
if [ -f "$DBCFG" ] && ! grep -q "PDO::MYSQL_ATTR_SSL_CA" "$DBCFG"; then
  echo "Patching config/database.php to enforce TLS..."
  cp "$DBCFG" "$DBCFG.bak"
  awk '
    BEGIN{inmysql=0; hasopt=0}
    { print }
    $0 ~ /'\''mysql'\''[[:space:]]*=>[[:space:]]*\[/ { inmysql=1; next }
    inmysql==1 && $0 ~ /options[[:space:]]*=>/ { hasopt=1 }
    inmysql==1 && $0 ~ /\],[[:space:]]*$/ {
      if (hasopt==0) {
        print "            '\''options'\'' => extension_loaded('\''pdo_mysql'\'') ? array_filter([\n                PDO::MYSQL_ATTR_SSL_CA => env('\''MYSQL_ATTR_SSL_CA'\''),\n            ]) : [],"
      }
      inmysql=0
    }
  ' "$DBCFG" > "$DBCFG.tmp" && mv "$DBCFG.tmp" "$DBCFG"
  echo "âœ… TLS configured."
fi

# --- 4. Dynamically Patch & Skip Migrations ---
MIGRATIONS_DIR="$APP_DIR/database/migrations"
if [ -d "$MIGRATIONS_DIR" ]; then
  echo "Scanning for incompatible and obsolete migrations..."

  # Rule 1: Skip migrations that use database triggers
  { grep -rilE 'CREATE[[:space:]]+TRIGGER|DROP[[:space:]]+TRIGGER' "$MIGRATIONS_DIR" 2>/dev/null || true; } \
  | grep -v '\.skipped$' \
  | while read -r f; do
      [ -f "$f" ] || continue
      echo "  -> Disabling trigger migration: $f"
      mv "$f" "$f.skipped"
    done

  # Rule 2: Skip migrations with known duplicate indexes
  find "$MIGRATIONS_DIR" -type f -name '*add_index*.php' ! -name '*.skipped' \
  | while read -r f; do
      echo "  -> Disabling duplicate-index migration: $f"
      mv "$f" "$f.skipped"
    done
  
  # Rule 3: Skip a list of specific obsolete migrations
  OBSOLETE_MIGRATIONS="
  2018_09_27_100017_update_rules.php
  2018_11_02_121027_create_registrations_table.php
  "
  echo "Disabling obsolete migrations:"
  echo "$OBSOLETE_MIGRATIONS" | while read -r migration_file; do
    [ -z "$migration_file" ] && continue
    TARGET_FILE="$MIGRATIONS_DIR/$migration_file"
    if [ -f "$TARGET_FILE" ]; then
      echo "  -> Skipping $TARGET_FILE"
      mv "$TARGET_FILE" "$TARGET_FILE.skipped"
    fi
  done
fi

# Rule 4: Find & replace the TiDB-incompatible view migration ANYWHERE in the app
echo "Scanning project for user_time_activity view migrations (any path)..."
ALL_VIEW_MIGS="$(
  {
    find "$APP_DIR" -path "$APP_DIR/vendor" -prune -o -path "$APP_DIR/storage" -prune -o -type f -name '*.php' \( \
      -iname '*user_time_activity*.php' -o \
      -iname '*user*last*time*usage*view*.php' -o \
      -iname '2019_03_26_113406_add_user_last_time_usage_view.php' \
    \) -print 2>/dev/null
    { grep -rilE 'CREATE([[:space:]]+OR[[:space:]]+REPLACE)?[[:space:]]+VIEW[[:space:]]+`?user_time_activity`?|user_time_activity' "$APP_DIR" 2>/dev/null || true; } | grep -v '/vendor/' | grep -v '/storage/'
    { grep -rilE 'AddUserLastTimeUsageView' "$APP_DIR" 2>/dev/null || true; } | grep -v '/vendor/' | grep -v '/storage/'
  } | sort -u
)"
ALL_VIEW_MIGS="$(printf "%s\n" "$ALL_VIEW_MIGS" | grep -vE '\.skipped$|_tidb\.php$' || true)"

if [ -n "$ALL_VIEW_MIGS" ]; then
  echo "Found and disabling incompatible view migration(s):"
  printf '%s\n' "$ALL_VIEW_MIGS" | while read -r f; do
    [ -f "$f" ] || continue
    if echo "$f" | grep -q '/database/'; then
      echo "  -> Skipping $f"
      mv "$f" "$f.skipped"
    elif grep -Eq 'CREATE([[:space:]]+OR[[:space:]]+REPLACE)?[[:space:]]+VIEW[[:space:]]+`?user_time_activity`?' "$f"; then
      echo "  -> Skipping $f (contains CREATE VIEW)"
      mv "$f" "$f.skipped"
    fi
  done

  TS="$(date +%Y_%m_%d_%H%M%S)"
  VIEW_MIG_NEW="$MIGRATIONS_DIR/${TS}_add_user_last_time_usage_view_tidb.php"
  cat > "$VIEW_MIG_NEW" <<'PHP'
<?php
use Illuminate\Support\Facades\DB;
use Illuminate\Database\Migrations\Migration;
return new class extends Migration {
    public function up(): void {
        DB::statement('DROP VIEW IF EXISTS user_time_activity');
        DB::statement(<<<'SQL'
CREATE VIEW user_time_activity AS SELECT ti.id AS time_interval_id, ti.user_id, ti.task_id, ti.end_at AS last_time_activity FROM time_intervals ti JOIN (SELECT user_id, MAX(end_at) AS max_end_at FROM time_intervals GROUP BY user_id) tmax ON ti.user_id = tmax.user_id AND ti.end_at = tmax.max_end_at
SQL
        );
    }
    public function down(): void { DB::statement('DROP VIEW IF EXISTS user_time_activity'); }
};
PHP
  echo "  -> Added compatible replacement: $VIEW_MIG_NEW"
fi

# Rule 5: Fix bad model reference in migrations (Rule -> Role) and add a fallback shim.
echo "Patching migrations that reference App\\Models\\Rule (typo) ..."
{ grep -ril --include='*.php' 'App\\Models\\Rule' "$APP_DIR" 2>/dev/null || true; } \
  | grep -v '/vendor/' | grep -v '/storage/' \
  | grep -vE '\.skipped$' \
  | while read -r f; do
      echo "  -> Fixing typo in $f"
      sed -i 's#App\\Models\\Rule#App\\Models\\Role#g' "$f"
    done

if [ ! -f "$APP_DIR/app/Models/Role.php" ]; then
  echo "Creating minimal App\\Models\\Role model (not found)..."
  mkdir -p "$APP_DIR/app/Models"
  cat > "$APP_DIR/app/Models/Role.php" <<'PHP'
<?php
namespace App\Models;
use Illuminate\Database\Eloquent\Model;
class Role extends Model { protected $guarded = []; public $timestamps = false; }
PHP
fi

# Ensure new Role model is autoloaded by Composer
if command -v composer >/dev/null 2>&1; then
  echo "Refreshing Composer autoloader..."
  composer dump-autoload -o || true
fi


# --- 5. Prepare and Launch Application ---
: "${PORT:=10000}"
echo "Clearing caches..."
php artisan config:clear
php artisan route:clear
php artisan view:clear
php artisan cache:clear

# Gate destructive migration command behind an environment variable
if [ "${RESET_DB:-0}" = "1" ]; then
  echo "RESET_DB=1 found. Wiping database and running all migrations from scratch..."
  php artisan migrate:fresh --seed --force
else
  echo "RESET_DB is not 1. Running incremental migrations..."
  php artisan migrate --force
  # Optionally run seeders on incremental deploys if flag is set
  if [ "${RUN_SEED:-0}" = "1" ]; then
    echo "RUN_SEED=1 found. Running database seeder..."
    php artisan db:seed --force
  fi
fi

echo "ðŸš€ Starting Cattr application server..."
php artisan serve --host 0.0.0.0 --port "$PORT"
