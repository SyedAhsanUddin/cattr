#!/bin/sh
set -e
(set -o pipefail) 2>/dev/null || true

# --- 1. Locate Laravel Project ---
# Find the 'artisan' file to locate the project root directory.
ARTISAN_FILE="$(find / -type f -name artisan 2>/dev/null | head -n1)"
if [ -z "$ARTISAN_FILE" ]; then
  echo "ERROR: Could not find Laravel 'artisan' file. Exiting."
  exit 1
fi
APP_DIR="$(dirname "$ARTISAN_FILE")"
cd "$APP_DIR"
echo "✅ Laravel project found at $APP_DIR"

# --- 2. Configure Environment (.env) ---
# Use the .env file from Render's secret files if it exists.
# Otherwise, create a .env file from individual environment variables.
if [ -f /etc/secrets/.env ]; then
  echo "Found secret file, copying to .env"
  cp /etc/secrets/.env "$APP_DIR/.env"
else
  echo "No secret file found. Building .env from environment variables."
  : "${APP_URL:=${RENDER_EXTERNAL_URL:-https://cattr-app.onrender.com}}"

  if [ -z "$DATABASE_URL" ]; then
    DATABASE_URL="mysql://${DB_USERNAME}:${DB_PASSWORD}@${DB_HOST}:${DB_PORT}/${DB_DATABASE}?ssl-mode=VERIFY_IDENTITY"
  fi

  cat > "$APP_DIR/.env" <<EOF
# --- Generated by start.sh ---
APP_NAME=Cattr
APP_ENV=production
APP_DEBUG=false
APP_KEY=${APP_KEY}
APP_URL=${APP_URL}
DATABASE_URL=${DATABASE_URL}
DB_CONNECTION=mysql
DB_HOST=${DB_HOST}
DB_PORT=${DB_PORT}
DB_DATABASE=${DB_DATABASE}
DB_USERNAME=${DB_USERNAME}
DB_PASSWORD=${DB_PASSWORD}
MYSQL_ATTR_SSL_CA=${MYSQL_ATTR_SSL_CA:-/etc/ssl/certs/ca-certificates.crt}
EOF
fi
sed -i 's/\r$//' "$APP_DIR/.env" || true

append_if_missing () {
  KEY="$1"; VALUE="$2"
  grep -q "^${KEY}=" "$APP_DIR/.env" || echo "${KEY}=${VALUE}" >> "$APP_DIR/.env"
}
echo "Appending safe defaults for cache, session, and queue drivers..."
append_if_missing LOG_CHANNEL stderr
append_if_missing CACHE_DRIVER file
append_if_missing SESSION_DRIVER file
append_if_missing QUEUE_CONNECTION sync

# --- 2b. Generate App Key If Missing ---
if [ -z "${APP_KEY:-}" ] || ! grep -q '^APP_KEY=' "$APP_DIR/.env"; then
  echo "Generating APP_KEY..."
  php artisan key:generate --force
fi

# --- 3. Enforce TLS for Database Connection ---
DBCFG="$APP_DIR/config/database.php"
if [ -f "$DBCFG" ] && ! grep -q "PDO::MYSQL_ATTR_SSL_CA" "$DBCFG"; then
  echo "Patching config/database.php to enforce TLS..."
  cp "$DBCFG" "$DBCFG.bak"
  awk '
    BEGIN{inmysql=0; hasopt=0}
    { print }
    $0 ~ /'\''mysql'\''[[:space:]]*=>[[:space:]]*\[/ { inmysql=1; next }
    inmysql==1 && $0 ~ /options[[:space:]]*=>/ { hasopt=1 }
    inmysql==1 && $0 ~ /\],[[:space:]]*$/ {
      if (hasopt==0) {
        print "            '\''options'\'' => extension_loaded('\''pdo_mysql'\'') ? array_filter([\n                PDO::MYSQL_ATTR_SSL_CA => env('\''MYSQL_ATTR_SSL_CA'\''),\n            ]) : [],"
      }
      inmysql=0
    }
  ' "$DBCFG" > "$DBCFG.tmp" && mv "$DBCFG.tmp" "$DBCFG"
  echo "✅ TLS configured."
fi

# --- 4. Dynamically Patch & Skip Migrations ---
MIGRATIONS_DIR="$APP_DIR/database/migrations"
if [ -d "$MIGRATIONS_DIR" ]; then
  echo "Scanning for incompatible and obsolete migrations..."

  # Rule 1: Skip migrations that use database triggers
  { grep -rilE 'CREATE[[:space:]]+TRIGGER|DROP[[:space:]]+TRIGGER' "$MIGRATIONS_DIR" 2>/dev/null || true; } \
  | grep -v '\.skipped$' \
  | while read -r f; do
      [ -f "$f" ] || continue
      echo "  -> Disabling trigger migration: $f"
      mv "$f" "$f.skipped"
    done

  # Rule 2: Skip migrations with known duplicate indexes
  find "$MIGRATIONS_DIR" -type f -name '*add_index*.php' ! -name '*.skipped' \
  | while read -r f; do
      echo "  -> Disabling duplicate-index migration: $f"
      mv "$f" "$f.skipped"
    done
  
  # Rule 3: Skip a list of specific obsolete migrations
  OBSOLETE_MIGRATIONS="
  2018_09_27_100017_update_rules.php
  2018_11_02_121027_create_registrations_table.php
  "
  echo "Disabling obsolete migrations:"
  echo "$OBSOLETE_MIGRATIONS" | while read -r migration_file; do
    [ -z "$migration_file" ] && continue
    TARGET_FILE="$MIGRATIONS_DIR/$migration_file"
    if [ -f "$TARGET_FILE" ]; then
      echo "  -> Skipping $TARGET_FILE"
      mv "$TARGET_FILE" "$TARGET_FILE.skipped"
    fi
  done
fi

# Rule 4: Find & replace the TiDB-incompatible view migration ANYWHERE in the app
echo "Scanning project for user_time_activity view migrations (any path)..."
ALL_VIEW_MIGS="$(
  {
    find "$APP_DIR" -path "$APP_DIR/vendor" -prune -o -path "$APP_DIR/storage" -prune -o -type f -name '*.php' \( \
      -iname '*user_time_activity*.php' -o \
      -iname '*user*last*time*usage*view*.php' -o \
      -iname '2019_03_26_113406_add_user_last_time_usage_view.php' \
    \) -print 2>/dev/null
    { grep -rilE 'CREATE([[:space:]]+OR[[:space:]]+REPLACE)?[[:space:]]+VIEW[[:space:]]+`?user_time_activity`?|user_time_activity' "$APP_DIR" 2>/dev/null || true; } | grep -v '/vendor/' | grep -v '/storage/'
    { grep -rilE 'AddUserLastTimeUsageView' "$APP_DIR" 2>/dev/null || true; } | grep -v '/vendor/' | grep -v '/storage/'
  } | sort -u
)"
ALL_VIEW_MIGS="$(printf "%s\n" "$ALL_VIEW_MIGS" | grep -vE '\.skipped$|_tidb\.php$' || true)"

if [ -n "$ALL_VIEW_MIGS" ]; then
  echo "Found and disabling incompatible view migration(s):"
  printf '%s\n' "$ALL_VIEW_MIGS" | while read -r f; do
    [ -f "$f" ] || continue
    if echo "$f" | grep -q '/database/'; then
      echo "  -> Skipping $f"
      mv "$f" "$f.skipped"
    elif grep -Eq 'CREATE([[:space:]]+OR[[:space:]]+REPLACE)?[[:space:]]+VIEW[[:space:]]+`?user_time_activity`?' "$f"; then
      echo "  -> Skipping $f (contains CREATE VIEW)"
      mv "$f" "$f.skipped"
    fi
  done

  TS="$(date +%Y_%m_%d_%H%M%S)"
  VIEW_MIG_NEW="$MIGRATIONS_DIR/${TS}_add_user_last_time_usage_view_tidb.php"
  cat > "$VIEW_MIG_NEW" <<'PHP'
<?php
use Illuminate\Support\Facades\DB;
use Illuminate\Database\Migrations\Migration;
return new class extends Migration {
    public function up(): void {
        DB::statement('DROP VIEW IF EXISTS user_time_activity');
        DB::statement(<<<'SQL'
CREATE VIEW user_time_activity AS SELECT ti.id AS time_interval_id, ti.user_id, ti.task_id, ti.end_at AS last_time_activity FROM time_intervals ti JOIN (SELECT user_id, MAX(end_at) AS max_end_at FROM time_intervals GROUP BY user_id) tmax ON ti.user_id = tmax.user_id AND ti.end_at = tmax.max_end_at
SQL
        );
    }
    public function down(): void { DB::statement('DROP VIEW IF EXISTS user_time_activity'); }
};
PHP
  echo "  -> Added compatible replacement: $VIEW_MIG_NEW"
fi

# Rule 5: Fix bad model reference in migrations (Rule -> Role) + add a safe shim
echo "Patching migrations that reference App\\Models\\Rule (typo) ..."
{ grep -rilF --include='*.php' 'App\Models\Rule' "$APP_DIR" 2>/dev/null || true; } \
  | grep -v '/vendor/' | grep -v '/storage/' \
  | grep -vE '\.skipped$' \
  | while read -r f; do
      [ -f "$f" ] || continue
      echo "  -> Fixing typo in $f"
      php -r "\$p='$f'; \$c=file_get_contents(\$p); \$c=str_replace('App\\\\Models\\\\Rule','App\\\\Models\\\\Role', \$c); file_put_contents(\$p,\$c);"
    done

# Ensure Role exists
if [ ! -f "$APP_DIR/app/Models/Role.php" ]; then
  echo "Creating minimal App\\Models\\Role model (not found)..."
  mkdir -p "$APP_DIR/app/Models"
  cat > "$APP_DIR/app/Models/Role.php" <<'PHP'
<?php
namespace App\Models;
use Illuminate\Database\Eloquent\Model;
class Role extends Model { protected $guarded = []; public $timestamps = false; }
PHP
fi
# Add a non-invasive shim so legacy references to Rule still work
if [ ! -f "$APP_DIR/app/Models/Rule.php" ]; then
  echo "Creating compatibility shim App\\Models\\Rule extends Role..."
  cat > "$APP_DIR/app/Models/Rule.php" <<'PHP'
<?php
namespace App\Models;
class Rule extends Role {}
PHP
fi
if command -v composer >/dev/null 2>&1; then
  echo "Refreshing Composer autoloader..."
  composer dump-autoload -o || true
fi

# Rule 6: Make the 'add_role_to_users' migration idempotent
ROLE_MIGRATION_FILE="$MIGRATIONS_DIR/2019_11_29_071129_add_role_to_users.php"
if [ -f "$ROLE_MIGRATION_FILE" ] && ! grep -q "Schema::hasColumn('users','role_id')" "$ROLE_MIGRATION_FILE"; then
  echo "Patching 'add_role_to_users' migration to be idempotent (early-return)..."
  awk '
    BEGIN { inup=0; injected=0 }
    /public[[:space:]]+function[[:space:]]+up[[:space:]]*\(/ {
      print
      inup=1
      # Handle "brace on same line"
      if (index($0,"{")) {
        if (!injected) {
          print "        if (\\Illuminate\\Support\\Facades\\Schema::hasColumn('\''users'\'','\''role_id'\'')) { return; }"
          injected=1
        }
        inup=0
      }
      next
    }
    inup && /\{/ {
      print
      if (!injected) {
        print "        if (\\Illuminate\\Support\\Facades\\Schema::hasColumn('\''users'\'','\''role_id'\'')) { return; }"
        injected=1
      }
      inup=0
      next
    }
    { print }
  ' "$ROLE_MIGRATION_FILE" > "$ROLE_MIGRATION_FILE.tmp" && mv "$ROLE_MIGRATION_FILE.tmp" "$ROLE_MIGRATION_FILE"
fi

# --- 5. Prepare and Launch Application ---
: "${PORT:=10000}"

echo "Ensuring writable dirs..."
mkdir -p storage bootstrap/cache
chmod -R ug+rwX storage bootstrap/cache || true
chown -R www-data:www-data storage bootstrap/cache 2>/dev/null || true
php artisan storage:link || true

echo "Clearing caches..."
php artisan config:clear
php artisan route:clear
php artisan view:clear
php artisan cache:clear

echo "Optimizing for production..."
php artisan optimize || true

run_migrate () {
  for i in 1 2 3 4 5; do
    php artisan migrate --force --no-interaction && return 0
    echo "Migrate attempt $i failed; retrying in 5s..."
    sleep 5
  done
  echo "Migrations failed after retries"; return 1
}

run_fresh () {
  for i in 1 2 3 4 5; do
    php artisan migrate:fresh --seed --force && return 0
    echo "migrate:fresh attempt $i failed; retrying in 5s..."
    sleep 5
  done
  echo "migrate:fresh failed after retries"; return 1
}

# Gate destructive migration command behind an environment variable
if [ "${RESET_DB:-0}" = "1" ]; then
  echo "RESET_DB=1 found. Wiping database and running all migrations from scratch..."
  run_fresh
else
  echo "RESET_DB is not 1. Running incremental migrations..."
  run_migrate
  # Optionally run seeders on incremental deploys if flag is set
  if [ "${RUN_SEED:-0}" = "1" ]; then
    echo "RUN_SEED=1 found. Running database seeder..."
    php artisan db:seed --force
  fi
fi

echo "🚀 Starting Cattr application server..."
php artisan serve --host 0.0.0.0 --port "$PORT"
